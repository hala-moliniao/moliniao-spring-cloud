# dubbo和springcloud有什么区别？

(1) dubbo的定位始终是一个RPC框架

(2) spring cloud
SpringCloud的目标是微服务架构下的一站式解决方案，基于SpringBoot提供了一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，熔断器等组件，除了基于NetFlix的开源组件做高度抽象封装之外，还有一些选型中立的开源组件。

SpringCloud利用SpringBoot的开发便利性巧妙地简化了分布式系统基础设施的开发，SpringCloud为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等,它们都可以用SpringBoot的开发风格做到一键启动和部署。

SpringBoot并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过SpringBoot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包

(3) 最大区别：SpringCloud抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式。
严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比
RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适。
品牌机与组装机的区别以及社区支持与更新力度

# Eureka比Zookeeper好在哪里？

(1) CAP：consistency、available、partition tolerance

CAP理论的核心是：任何一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能满足两个。

Mysql、Oracle、sqlServer：CA-->单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大；

HBase、MongoDB、Redis：CP-->满足一致性，分区容错性的系统，通常性能不是特别高；

CouchDB、Cassandra、DynamoDB：AP-->满足可用性，分区容错性的系统，通常可能对一致性要求低一些

(2) Eureka遵循AP
Eureka各个节点都是平等的，Eureka的客户端在向某个Eureka注册服务时如果发现连接失败，
则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用。只不过查到的信息可能不是最新的(不保证强一致性)。
除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心
出现了网络故障，此时会出现以下三种情况：

1.Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务；

2.Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)；

3.当网络稳定时，当前实例新的注册信息会被同步到其它节点中。

Eureka可用很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样是整个注册瘫痪。

(3) Zookeeper遵循CP
当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟之前的注册信息，但不能接受服务直接down掉不可用。也就是说服务注册功能
对可用性的要求要高于一致性。但zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点重新进行leader选取，问
题在于选取leader的时间太长，30~120s，且选举期间整个zk集群都是不可用的，这就导致选举期间注册服务瘫痪，在云部署的环境下，因网络问题
使得zk集群失去master节点是较大概率的事情，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。

# Ribbon是什么？

Ribbon是基于Netflix Ribbon实现的一套客户端,负载均衡的工具。主要功能是提供客户端的软负载均衡算法,将Netflix的中间服务层服务连接在
一起,将用户的请求平摊的分配到多个服务上,从而达到系统的HA高可用。

分为两种：

集中式的LB(偏硬件，如F5):在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5，也可以是软件，如Nginx)，由该设施负责把访问
请求通过某种策略转发至服务的提供方。

进程内的(偏软件,如Nginx)：将LB集成到消费方，消费方从服务注册中心获取哪些服务地址可用，然后自己再从这些地址中选择一个合适的服务器。

Ribbon就属于进程内的,它只是一个库类,集成与消费方进程,消费方通过它来获取服务提供方的地址,Ribbon其实就是一个软负载均衡的客户端组件,
它可以和其他所需请求的客户端结合使用,和eureka结合只是一个实例。
Ribbon和Eureka整合后Consumer可以直接调用服务而不用再关心地址和端口号

负载均衡接口IRule：

实现AbstractLoadBalancerRule的配置类不能放在@ComponentScan所扫描的当前包及其子包下，即不在主启动类所在包下,否则我们自定义的这个
配置类就会被所有的Ribbon客户端所共享,也就是说我们达不到特殊化定制的目的了。

1.RoundRobinRule 轮询
2.RandomRule 随机
3.RetryRule 先按照RoundRobinRule的策略获取服务，如果获取服务失败则再指定时间内进行重试，获取可用的服务
4.AvailabilityFilteringRule 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，还有并发的连接数量超过阈值的服务，然后对剩余
的服务列表按照轮询策略进行访问
5.BestAvailableRule 会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务
6.ZoneAvoidanceRule 默认规则，复合判断server所在区域的性能和server的可用性选择服务器
7.WeightedResponseTimeRule 根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越高，刚启动时如果统计信息不足
则使用RoundRobinRule策略，等统计信息足够，会切换到WeightedResponseTimeRule



# Feign是什么？

Feign是声明式WebService客户端,Spring cloud对Feign进行了封装,使其支持spring mvc标准注解和HttpMessageConverters可以
与Ribbon、Eureka组合使用以支持负载均衡,旨在使得编写Java Http客户端更加容易,只需要创建一个接口,然后再上面加一个注解。

Feign是怎么出来的？
大部分的开发者都可以接受直接调用我们的微服务来进行访问，但因为目前大家都习惯面向接口编程，比如WebService，比如我们的Mapper接口
通过接口+注解获得我们的调用服务，通过微服务名字获取服务

# Hystrix是什么？

Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的调用失败，比如超时、异常,Hystrix能够保证在
一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。

断路器本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控向调用方返回一个符合预期的、可处理的备选响应(Fallback),
而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。

服务雪崩：多个微服务之间调用的时候，A->B->C->D->E,这就是扇出，如果扇出的链路上某个微服务的调用时间过长或者不可用，对微服务A
的调用就会占用就会越来越多的系统资源，进而引起系统崩溃，所谓的雪崩效应。

服务熔断：熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务不可用或者响应时间太长时，进行服务的降级，进而熔断
该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在spring cloud框架里熔断机制通过Hystrix实现。
Hystrix会监控微服务间的调用状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，就会启动熔断机制，其注解是@HystrixCommand。

一般是某个服务故障或者异常引起，类似现实世界中的保险丝，当某个异常条件被触发，直接熔断整个服务，而不是一直等到此服务超时。

服务降级:整体服务不够用了，忍痛将某些服务关掉，待渡过难关，再开启回来。
所谓降级一般是从整体负荷考虑，就是当某个服务熔断之后，服务器将不再调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值，
这样做虽然服务水平下降，但好歹可用，比直接挂掉强。

# Zuul是什么？

zuul包含了对请求的路由和过滤两个最主要的功能

其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验
服务聚合等功能的基础。Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他微服务得消息，也即以后访问微服务
都是通过Zuul跳转后获得。Zuul最终还是会注册进行Eureka

提供=代理+路由+过滤三大功能

无路由: http://localhost:8081/getOrder?studentId=1

有路由: http://zuul.com:9527/moliniao-provider-ribbon/getOrder?studentId=2  //moliniao-provider-ribbon为微服务名称，即应用程序名称

# Config分布式配置中心是什么？

微服务意味着要将单体应用中的业务拆分为一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要配置必要的配置信息才能运行，所以一套集中式的、动态的
配置管理设施是必不可少的，SpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理......

SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同的微服务应用的所有环境提供了一个中心化的外部配置。

SpringCloud Config分为服务端和客户端两部分。服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口。

客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置
进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。
集中管理配置文件，不同环境不同配置，动态化的配置更新，分环境部署，运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息，
当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置，将配置信息以REST接口的形式暴露。
