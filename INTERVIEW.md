# dubbo和springcloud有什么区别？

(1) dubbo的定位始终是一个RPC框架

(2) spring cloud
SpringCloud的目标是微服务架构下的一站式解决方案，基于SpringBoot提供了一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，熔断器等组件，除了基于NetFlix的开源组件做高度抽象封装之外，还有一些选型中立的开源组件。

SpringCloud利用SpringBoot的开发便利性巧妙地简化了分布式系统基础设施的开发，SpringCloud为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等,它们都可以用SpringBoot的开发风格做到一键启动和部署。

SpringBoot并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过SpringBoot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包

(3) 最大区别：SpringCloud抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式。
严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比
RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适。
品牌机与组装机的区别以及社区支持与更新力度

# Eureka比Zookeeper好在哪里？

(1) CAP：consistency、available、partition tolerance

CAP理论的核心是：任何一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能满足两个。

Mysql、Oracle、sqlServer：CA-->单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大；

HBase、MongoDB、Redis：CP-->满足一致性，分区容错性的系统，通常性能不是特别高；

CouchDB、Cassandra、DynamoDB：AP-->满足可用性，分区容错性的系统，通常可能对一致性要求低一些

(2) Eureka遵循AP
Eureka各个节点都是平等的，Eureka的客户端在向某个Eureka注册服务时如果发现连接失败，
则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用。只不过查到的信息可能不是最新的(不保证强一致性)。
除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心
出现了网络故障，此时会出现以下三种情况：

1.Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务；

2.Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)；

3.当网络稳定时，当前实例新的注册信息会被同步到其它节点中。

Eureka可用很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样是整个注册瘫痪。

(3) Zookeeper遵循CP
当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟之前的注册信息，但不能接受服务直接down掉不可用。也就是说服务注册功能
对可用性的要求要高于一致性。但zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点重新进行leader选取，问
题在于选取leader的时间太长，30~120s，且选举期间整个zk集群都是不可用的，这就导致选举期间注册服务瘫痪，在云部署的环境下，因网络问题
使得zk集群失去master节点是较大概率的事情，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。

# Ribbon是什么？

Ribbon是基于Netflix Ribbon实现的一套客户端,负载均衡的工具。主要功能是提供客户端的软负载均衡算法,将Netflix的中间服务层服务连接在
一起,将用户的请求平摊的分配到多个服务上,从而达到系统的HA高可用。

分为两种：

集中式的LB(偏硬件，如F5)

进程内的(偏软件,如Nginx)：将LB集成到消费方，消费方从服务注册中心获取哪些服务地址可用，然后自己再从这些地址中选择一个合适的服务器。

Ribbon就属于进程内的,它只是一个库类,集成与消费方进程,消费方通过它来获取服务提供方的地址,Ribbon其实就是一个软负载均衡的客户端组件,
它可以和其他所需请求的客户端结合使用,和eureka结合只是一个实例。

负载均衡接口IRule：

实现AbstractLoadBalancerRule的配置类不能放在@ComponentScan所扫描的当前包及其子包下，即不在主启动类所在包下,否则我们自定义的这个
配置类就会被所有的Ribbon客户端所共享,也就是说我们达不到特殊化定制的目的了。

# Feign是什么？

Feign是声明式WebService客户端,Spring cloud对Feign进行了封装,使其支持spring mvc标准注解和HttpMessageConverters可以
与Ribbon、Eureka组合使用以支持负载均衡,旨在使得编写Java Http客户端更加容易,只需要创建一个接口,然后再上面加一个注解。

# Hystrix

Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的调用失败，比如超时、异常,Hystrix能够保证在
一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。

断路器本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控向调用方返回一个符合预期的、可处理的备选响应(Fallback),
而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要的占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。

服务雪崩：多个微服务之间调用的时候，A->B->C->D->E,这就是扇出，如果扇出的链路上某个微服务的调用时间过长或者不可用，对微服务A
的调用就会占用就会越来越多的系统资源，进而引起系统崩溃，所谓的雪崩效应。

服务熔断：熔断机制是应对雪崩效应的一种微服务链路保护机制。当扇出链路的某个微服务不可用或者响应时间太长时，进行服务的降级，进而熔断该节点微服务的调用，快速返回错误的响应信息
当检测到该节点微服务调用响应正常后恢复调用链路。在spring cloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间的调用状况，当失败的调用到一定阈值，缺省是5秒内20次调用失败，
就会启动熔断机制，其注解是@HystrixCommand。

一般是某个服务故障或者异常引起，类似现实世界中的保险丝，当某个异常条件被触发，直接熔断整个服务，而不是一直等到此服务超时。

服务降级:整体服务不够用了，忍痛将某些服务关掉，待渡过难关，再开启回来。
所谓降级一般是从整体负荷考虑，就是当某个服务熔断之后，服务器将不再调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值，
这样做虽然服务水平下降，但好歹可用，比直接挂掉强。
